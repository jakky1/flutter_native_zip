// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/native_zip.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class NativeZipBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeZipBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeZipBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<NativeNotifyMessage> getDartMessage() {
    return _getDartMessage();
  }

  late final _getDartMessagePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NativeNotifyMessage> Function()>>(
          'getDartMessage');
  late final _getDartMessage = _getDartMessagePtr
      .asFunction<ffi.Pointer<NativeNotifyMessage> Function()>();

  /// --------------------------------------------------------------------------
  /// zlib stream
  /// --------------------------------------------------------------------------
  ffi.Pointer<ffi.Void> openZipStream(
    int windowBits,
    int compressLevel,
  ) {
    return _openZipStream(
      windowBits,
      compressLevel,
    );
  }

  late final _openZipStreamPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int, ffi.Int)>>(
      'openZipStream');
  late final _openZipStream =
      _openZipStreamPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int writeZipStream(
    ffi.Pointer<ffi.Void> pStream,
    int isZipping,
    ffi.Pointer<ffi.Int8> inBuf,
    int inBufSize,
    ffi.Pointer<ffi.Int8> outBuf,
    int outBufSize,
    int isEOF,
  ) {
    return _writeZipStream(
      pStream,
      isZipping,
      inBuf,
      inBufSize,
      outBuf,
      outBufSize,
      isEOF,
    );
  }

  late final _writeZipStreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Pointer<ffi.Int8>,
              ffi.Int,
              ffi.Pointer<ffi.Int8>,
              ffi.Int,
              ffi.Int)>>('writeZipStream');
  late final _writeZipStream = _writeZipStreamPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Int8>, int,
          ffi.Pointer<ffi.Int8>, int, int)>();

  int writeZipStream_readNext(
    ffi.Pointer<ffi.Void> _pStream,
    int isZipping,
    ffi.Pointer<ffi.Int8> outBuf,
    int outBufSize,
    int isEOF,
  ) {
    return _writeZipStream_readNext(
      _pStream,
      isZipping,
      outBuf,
      outBufSize,
      isEOF,
    );
  }

  late final _writeZipStream_readNextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Pointer<ffi.Int8>,
              ffi.Int,
              ffi.Int)>>('writeZipStream_readNext');
  late final _writeZipStream_readNext = _writeZipStream_readNextPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Int8>, int, int)>();

  void closeZipStream(
    ffi.Pointer<ffi.Void> pStream,
  ) {
    return _closeZipStream(
      pStream,
    );
  }

  late final _closeZipStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'closeZipStream');
  late final _closeZipStream =
      _closeZipStreamPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> openUnzipStream(
    int windowBits,
  ) {
    return _openUnzipStream(
      windowBits,
    );
  }

  late final _openUnzipStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int)>>(
          'openUnzipStream');
  late final _openUnzipStream =
      _openUnzipStreamPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  void closeUnzipStream(
    ffi.Pointer<ffi.Void> pStream,
  ) {
    return _closeUnzipStream(
      pStream,
    );
  }

  late final _closeUnzipStreamPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'closeUnzipStream');
  late final _closeUnzipStream =
      _closeUnzipStreamPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> zipDirAsync(
    ffi.Pointer<ffi.Void> _zip,
    bool hasPassword,
    ffi.Pointer<ffi.Pointer<ffi.Char>> dirPathList,
    int dirPathListCount,
    ffi.Pointer<ffi.Char> entryDirPathBase,
    int compressLevel,
    int skipTopLevel,
    int threadCount,
  ) {
    return _zipDirAsync(
      _zip,
      hasPassword,
      dirPathList,
      dirPathListCount,
      entryDirPathBase,
      compressLevel,
      skipTopLevel,
      threadCount,
    );
  }

  late final _zipDirAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('zipDirAsync');
  late final _zipDirAsync = _zipDirAsyncPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          bool,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          int,
          int)>();

  ffi.Pointer<ffi.Void> unzipToDirAsync(
    ffi.Pointer<ffi.Void> _zip,
    ffi.Pointer<ffi.Char> password,
    ffi.Pointer<ffi.Char> zipFilePath,
    ffi.Pointer<ffi.Pointer<ffi.Char>> entryPathsArr,
    int entriesCount,
    ffi.Pointer<ffi.Char> toDirPath,
    int threadCount,
  ) {
    return _unzipToDirAsync(
      _zip,
      password,
      zipFilePath,
      entryPathsArr,
      entriesCount,
      toDirPath,
      threadCount,
    );
  }

  late final _unzipToDirAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('unzipToDirAsync');
  late final _unzipToDirAsync = _unzipToDirAsyncPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int,
          ffi.Pointer<ffi.Char>,
          int)>();

  int zipRenameEntryAsync(
    ffi.Pointer<ffi.Void> _zip,
    ffi.Pointer<ffi.Char> entryPath,
    ffi.Pointer<ffi.Char> newEntryPath,
  ) {
    return _zipRenameEntryAsync(
      _zip,
      entryPath,
      newEntryPath,
    );
  }

  late final _zipRenameEntryAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('zipRenameEntryAsync');
  late final _zipRenameEntryAsync = _zipRenameEntryAsyncPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int zipMoveEntriesAsync(
    ffi.Pointer<ffi.Void> _zip,
    ffi.Pointer<ffi.Pointer<ffi.Char>> entryPaths,
    int entriesCount,
    ffi.Pointer<ffi.Char> newEntryBasePath,
  ) {
    return _zipMoveEntriesAsync(
      _zip,
      entryPaths,
      entriesCount,
      newEntryBasePath,
    );
  }

  late final _zipMoveEntriesAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('zipMoveEntriesAsync');
  late final _zipMoveEntriesAsync = _zipMoveEntriesAsyncPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int, ffi.Pointer<ffi.Char>)>();

  int zipRemoveEntriesAsync(
    ffi.Pointer<ffi.Void> _zip,
    ffi.Pointer<ffi.Pointer<ffi.Char>> entryPaths,
    int entriesCount,
  ) {
    return _zipRemoveEntriesAsync(
      _zip,
      entryPaths,
      entriesCount,
    );
  }

  late final _zipRemoveEntriesAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int)>>('zipRemoveEntriesAsync');
  late final _zipRemoveEntriesAsync = _zipRemoveEntriesAsyncPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  ffi.Pointer<ffi.Void> openZip(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _openZip(
      filename,
      password,
    );
  }

  late final _openZipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('openZip');
  late final _openZip = _openZipPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int closeZip(
    ffi.Pointer<ffi.Void> zip,
  ) {
    return _closeZip(
      zip,
    );
  }

  late final _closeZipPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'closeZip');
  late final _closeZip =
      _closeZipPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void discardZip(
    ffi.Pointer<ffi.Void> zip,
  ) {
    return _discardZip(
      zip,
    );
  }

  late final _discardZipPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'discardZip');
  late final _discardZip =
      _discardZipPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<NativeZipEntry> getZipEntries(
    ffi.Pointer<ffi.Void> zip,
    ffi.Pointer<ffi.Int> outCount,
    ffi.Pointer<ffi.Char> path,
    int isRecursive,
  ) {
    return _getZipEntries(
      zip,
      outCount,
      path,
      isRecursive,
    );
  }

  late final _getZipEntriesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NativeZipEntry> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('getZipEntries');
  late final _getZipEntries = _getZipEntriesPtr.asFunction<
      ffi.Pointer<NativeZipEntry> Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>, int)>();

  void nativeFree(
    ffi.Pointer<ffi.Void> p,
  ) {
    return _nativeFree(
      p,
    );
  }

  late final _nativeFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'nativeFree');
  late final _nativeFree =
      _nativeFreePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> readZipFileEntryOpenByIndex(
    ffi.Pointer<ffi.Void> zip,
    int index,
  ) {
    return _readZipFileEntryOpenByIndex(
      zip,
      index,
    );
  }

  late final _readZipFileEntryOpenByIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('readZipFileEntryOpenByIndex');
  late final _readZipFileEntryOpenByIndex = _readZipFileEntryOpenByIndexPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> readZipFileEntryOpen(
    ffi.Pointer<ffi.Void> zip,
    ffi.Pointer<ffi.Char> entryPath,
  ) {
    return _readZipFileEntryOpen(
      zip,
      entryPath,
    );
  }

  late final _readZipFileEntryOpenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>)>>('readZipFileEntryOpen');
  late final _readZipFileEntryOpen = _readZipFileEntryOpenPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  int readZipFileEntry(
    ffi.Pointer<ffi.Void> zipEntryFile,
    ffi.Pointer<ffi.Int8> buf,
    int len,
  ) {
    return _readZipFileEntry(
      zipEntryFile,
      buf,
      len,
    );
  }

  late final _readZipFileEntryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int8>,
              ffi.Int)>>('readZipFileEntry');
  late final _readZipFileEntry = _readZipFileEntryPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int8>, int)>();

  int readZipFileEntryClose(
    ffi.Pointer<ffi.Void> zipEntryFile,
  ) {
    return _readZipFileEntryClose(
      zipEntryFile,
    );
  }

  late final _readZipFileEntryClosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'readZipFileEntryClose');
  late final _readZipFileEntryClose = _readZipFileEntryClosePtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();
}

/// --------------------------------------------------------------------------
/// dart notify
/// --------------------------------------------------------------------------
enum DartNotifyAction {
  TASK_FINISH(0),
  TASK_WARNING(1),
  TASK_ERROR(2),

  /// print log
  TASK_LOG(3);

  final int value;
  const DartNotifyAction(this.value);

  static DartNotifyAction fromValue(int value) => switch (value) {
        0 => TASK_FINISH,
        1 => TASK_WARNING,
        2 => TASK_ERROR,
        3 => TASK_LOG,
        _ => throw ArgumentError("Unknown value for DartNotifyAction: $value"),
      };
}

final class NativeNotifyMessage extends ffi.Struct {
  @ffi.Int()
  external int taskId;

  /// values in [DartNotifyAction]
  @ffi.Int()
  external int action;

  @ffi.Int()
  external int errCode;

  external ffi.Pointer<ffi.Char> errMsg;
}

/// --------------------------------------------------------------------------
/// zip utils
/// --------------------------------------------------------------------------
final class NativeZipTaskProgressInfo extends ffi.Struct {
  external ffi.Pointer<ffi.Char> now_processing_filePath;

  @ffi.Size()
  external int total_fileSize;

  @ffi.Size()
  external int processed_fileSize;

  @ffi.Size()
  external int processed_compressSize;
}

final class NativeZipTaskInfo extends ffi.Struct {
  @ffi.Int()
  external int taskId;

  @ffi.Int()
  external int errCode;

  @ffi.Bool()
  external bool isCancelled;

  @ffi.Bool()
  external bool isDone;

  external NativeZipTaskProgressInfo progress;
}

/// --------------------------------------------------------------------------
/// zip
/// --------------------------------------------------------------------------
final class NativeZipEntry extends ffi.Struct {
  @ffi.Uint64()
  external int index;

  external ffi.Pointer<ffi.Char> path;

  @ffi.Uint64()
  external int originalSize;

  @ffi.Uint64()
  external int compressedSize;

  @time_t()
  external int modifiedTime;
}

typedef time_t = __time64_t;
typedef __time64_t = ffi.LongLong;
typedef Dart__time64_t = int;

enum NativeZipErrors {
  ERR_NZ_MIN(-10000),
  ERR_NZ_CANCELLED(-9999),
  ERR_NZ_DIR_TRAVERSAL_FILE_NOTFOUND(-9998),
  ERR_NZ_DIR_TRAVERSAL_NO_MORE_FILE(-9997),
  ERR_NZ_DIR_TRAVERSAL_PATH_TOO_LONG(-9996),
  ERR_NZ_INVALID_ARGUMENT(-9995),

  /// malicious path, or entry path not ends with '/' for a dir
  ERR_NZ_INVALID_PATH(-9994),
  ERR_NZ_ZIP_HAS_MALICIOUS_PATH(-9993),
  ERR_NZ_INTERNAL_ERROR(-9992),
  ERR_NZ_MKDIR(-9991),
  ERR_NZ_ZIP_ENTRY_NOT_FOUND(-9990),

  /// try to add / move / rename to an entry which is already exists
  ERR_NZ_ZIP_ENTRY_ALREADY_EXISTS(-9989),
  ERR_NZ_FILE_ALREADY_EXISTS(-9988),
  ERR_NZ_MAX(-9987);

  final int value;
  const NativeZipErrors(this.value);

  static NativeZipErrors fromValue(int value) => switch (value) {
        -10000 => ERR_NZ_MIN,
        -9999 => ERR_NZ_CANCELLED,
        -9998 => ERR_NZ_DIR_TRAVERSAL_FILE_NOTFOUND,
        -9997 => ERR_NZ_DIR_TRAVERSAL_NO_MORE_FILE,
        -9996 => ERR_NZ_DIR_TRAVERSAL_PATH_TOO_LONG,
        -9995 => ERR_NZ_INVALID_ARGUMENT,
        -9994 => ERR_NZ_INVALID_PATH,
        -9993 => ERR_NZ_ZIP_HAS_MALICIOUS_PATH,
        -9992 => ERR_NZ_INTERNAL_ERROR,
        -9991 => ERR_NZ_MKDIR,
        -9990 => ERR_NZ_ZIP_ENTRY_NOT_FOUND,
        -9989 => ERR_NZ_ZIP_ENTRY_ALREADY_EXISTS,
        -9988 => ERR_NZ_FILE_ALREADY_EXISTS,
        -9987 => ERR_NZ_MAX,
        _ => throw ArgumentError("Unknown value for NativeZipErrors: $value"),
      };
}

const int MIN_TASK_ID = 888;
